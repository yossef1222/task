# -*- coding: utf-8 -*-
"""Untitled19.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1XszwFQbUEcWA4U6-3O05flkyKKv5-2SJ
"""



from google.colab import drive
drive.mount('/content/drive')

import pandas as pd
import numpy as np

df = pd.read_csv("/content/drive/MyDrive/data.csv")
df.head()

df["price_class"] = pd.qcut(df["price"], 3, labels=["Low", "Medium", "High"])
df["price_class"].value_counts()

from sklearn.preprocessing import LabelEncoder, MinMaxScaler
from sklearn.model_selection import train_test_split

# handle missing
df = df.fillna(df.mean(numeric_only=True))

# Encode categorical columns
label_cols = df.select_dtypes(include="object").columns
encoders = {}
for col in label_cols:
    enc = LabelEncoder()
    df[col] = enc.fit_transform(df[col])
    encoders[col] = enc

# Split
X = df.drop("price_class", axis=1)
y = df["price_class"]

X_train, X_test, y_train, y_test = train_test_split(
    X, y, test_size=0.2, random_state=42
)

# Scale
scaler = MinMaxScaler()
X_train_s = scaler.fit_transform(X_train)
X_test_s  = scaler.transform(X_test)

X_train_s[:3]

from sklearn.neighbors import KNeighborsClassifier
from sklearn.metrics import accuracy_score, precision_score, recall_score, f1_score, confusion_matrix

knn = KNeighborsClassifier(n_neighbors=5)
knn.fit(X_train_s, y_train)
pred_knn = knn.predict(X_test_s)
print("=== KNN ===")
print("Accuracy:", accuracy_score(y_test, pred_knn))
print("Precision:", precision_score(y_test, pred_knn, average='macro'))
print("Recall:", recall_score(y_test, pred_knn, average='macro'))
print("F1:", f1_score(y_test, pred_knn, average='macro'))
print("Confusion Matrix:\n", confusion_matrix(y_test, pred_knn))

from sklearn.naive_bayes import GaussianNB

nb = GaussianNB()
nb.fit(X_train_s, y_train)
pred_nb = nb.predict(X_test_s)
print("=== Naive Bayes ===")
print("Accuracy:", accuracy_score(y_test, pred_nb))
print("Precision:", precision_score(y_test, pred_nb, average='macro'))
print("Recall:", recall_score(y_test, pred_nb, average='macro'))
print("F1:", f1_score(y_test, pred_nb, average='macro'))
print("Confusion Matrix:\n", confusion_matrix(y_test, pred_nb))

from sklearn.svm import SVC

svm = SVC(kernel="rbf")
svm.fit(X_train_s, y_train)
pred_svm = svm.predict(X_test_s)

print("=== SVM ===")
print("Accuracy:", accuracy_score(y_test, pred_svm))
print("Precision:", precision_score(y_test, pred_svm, average='macro'))
print("Recall:", recall_score(y_test, pred_svm, average='macro'))
print("F1:", f1_score(y_test, pred_svm, average='macro'))
print("Confusion Matrix:\n", confusion_matrix(y_test, pred_svm))

from sklearn.neural_network import MLPClassifier

ann = MLPClassifier(hidden_layer_sizes=(32,16), activation="relu", max_iter=300)
ann.fit(X_train_s, y_train)
pred_ann = ann.predict(X_test_s)

print("=== ANN ===")
print("Accuracy:", accuracy_score(y_test, pred_ann))
print("Precision:", precision_score(y_test, pred_ann, average='macro'))
print("Recall:", recall_score(y_test, pred_ann, average='macro'))
print("F1:", f1_score(y_test, pred_ann, average='macro'))
print("Confusion Matrix:\n", confusion_matrix(y_test, pred_ann))


from deap import base, creator, tools
from sklearn.svm import SVC
import random

n_features = X_train_s.shape[1]

creator.create("FitnessMax", base.Fitness, weights=(1.0,))
creator.create("Individual", list, fitness=creator.FitnessMax)

toolbox = base.Toolbox()
toolbox.register("attr_bool", random.randint, 0, 1)
toolbox.register("individual", tools.initRepeat, creator.Individual, toolbox.attr_bool, n_features)
toolbox.register("population", tools.initRepeat, list, toolbox.individual)

def fitness(ind):
    mask = np.array(ind)==1
    if mask.sum() == 0:
        return (0,)

    model = SVC(kernel="rbf")
    model.fit(X_train_s[:,mask], y_train)
    pred = model.predict(X_test_s[:,mask])
    return (accuracy_score(y_test, pred),)

toolbox.register("evaluate", fitness)
toolbox.register("mate", tools.cxTwoPoint)
toolbox.register("mutate", tools.mutFlipBit, indpb=0.05)
toolbox.register("select", tools.selTournament, tournsize=3)

pop = toolbox.population(20)

for gen in range(10):
    offspring = toolbox.select(pop, len(pop))
    offspring = list(map(toolbox.clone, offspring))

    for c1, c2 in zip(offspring[::2], offspring[1::2]):
        if random.random() < 0.8:
            toolbox.mate(c1, c2)

    for m in offspring:
        if random.random() < 0.2:
            toolbox.mutate(m)

    for ind in offspring:
        ind.fitness.values = toolbox.evaluate(ind)

    pop = offspring
    print("Generation", gen)

best = tools.selBest(pop, 1)[0]
best, sum(best)

mask = np.array(best)==1
X_train_r = X_train_s[:,mask]
X_test_r  = X_test_s[:,mask]

knn = KNeighborsClassifier(n_neighbors=5)
knn.fit(X_train_r, y_train)
pred_knn = knn.predict(X_test_r)
print("=== KNN ===")
print("Accuracy:", accuracy_score(y_test, pred_knn))
print("Precision:", precision_score(y_test, pred_knn, average='macro'))
print("Recall:", recall_score(y_test, pred_knn, average='macro'))
print("F1:", f1_score(y_test, pred_knn, average='macro'))
print("Confusion Matrix:\n", confusion_matrix(y_test, pred_knn))

nb = GaussianNB()
nb.fit(X_train_r, y_train)
pred_nb = nb.predict(X_test_r)
print("=== Naive Bayes ===")
print("Accuracy:", accuracy_score(y_test, pred_nb))
print("Precision:", precision_score(y_test, pred_nb, average='macro'))
print("Recall:", recall_score(y_test, pred_nb, average='macro'))
print("F1:", f1_score(y_test, pred_nb, average='macro'))
print("Confusion Matrix:\n", confusion_matrix(y_test, pred_nb))

svm = SVC(kernel="rbf")
svm.fit(X_train_r, y_train)
pred_svm = svm.predict(X_test_r)

print("=== SVM ===")
print("Accuracy:", accuracy_score(y_test, pred_svm))
print("Precision:", precision_score(y_test, pred_svm, average='macro'))
print("Recall:", recall_score(y_test, pred_svm, average='macro'))
print("F1:", f1_score(y_test, pred_svm, average='macro'))
print("Confusion Matrix:\n", confusion_matrix(y_test, pred_svm))

ann = MLPClassifier(hidden_layer_sizes=(32,16), activation="relu", max_iter=300)
ann.fit(X_train_r, y_train)
pred_ann = ann.predict(X_test_r)

print("=== ANN ===")
print("Accuracy:", accuracy_score(y_test, pred_ann))
print("Precision:", precision_score(y_test, pred_ann, average='macro'))
print("Recall:", recall_score(y_test, pred_ann, average='macro'))
print("F1:", f1_score(y_test, pred_ann, average='macro'))
print("Confusion Matrix:\n", confusion_matrix(y_test, pred_ann))